* Ad-hoc promitives
** ~(car LIST)~
Return the head of ~LIST~.

#+begin_src lisp
(let list '(1 2 3 4 5))
(car list) ; => (1)
#+end_src

** ~(cdr LIST)~
Return the tail of ~LIST~.

#+begin_src lisp
(let list '(1 2 3 4 5))
(cdr list) ; => (2 3 4 5)
#+end_src

** ~(nth INDEX LIST)~
Return the ~INDEX~-th element of ~LIST~.

#+begin_src lisp
(let list '(1 2 3 4 5))
(nth 0 list) ; => 1
(nth 9 list) ; => nil
#+end_src

** ~(cons VALUE ...)~
Combine the values together into a single list.

#+begin_src lisp
(cons '(1 2) '(3 4) '((5 6) 7)) ; => (1 2 3 4 5 6 7)
#+end_src

** ~(append VALUE ...)~
Same as =cons=

#+begin_src lisp
(append '(1 2) '(3 4) '((5 6) 7)) ; => (1 2 3 4 5 6 7)
#+end_src

Only there for domain-specific terms, which I think is super important
for writing readable code.

** ~(print VALUE ...)~
Print the values sequentially separated by newlines.

#+begin_src lisp
(print "Hello, world" "Hello, universe")
#+end_src

#+begin_src console
$ lust print.lisp
Hello, world
Hello, universe
#+end_src

* Boolean conditions
** ~(and VALUE ...)~
Returns ~true~ if all the values are truthy. Exhibits short-circuit
behaviour.

#+begin_src lisp
(and 1 true "cool" 'meh)     ; => true
(and 0 true "cool" 'meh)     ; => false
(and 1 false "cool" 'meh)    ; => false
(and 1 true "cool" 'meh nil) ; => false
#+end_src

In lust, values which are considered false include ~0~, ~nil~ and
~false~.

** ~(or VALUE ...)~
Returns ~true~ if any one of the values are truthy. Exhibits
short-circuit behaviour.

#+begin_src lisp
(and 1 true "cool" 'meh)  ; => true
(and 0 true "cool" 'meh)  ; => true
(and 0 false nil 'meh)    ; => true
(and 0 false nil)         ; => false
#+end_src

** ~(not VALUE)~
Returns ~true~ if ~VALUE~ is not truthy.

#+begin_src lisp
(not 0)      ; => true
(not false)  ; => true
(not nil)    ; => true
(not 1)      ; => false
(not 'meh)   ; => false
#+end_src

* Equality
** ~(= VALUE ...)~
Returns ~true~ if all the values are equal.

#+begin_src lisp
(= "string" "string" "string") ; => true
(= 5 5.0 (/ 25 5))             ; => true
(= 'yeah 'yeah)                ; => true
(= nil nil)                    ; => true

(= "foo" "bar")                ; => false
(= 5 7)                        ; => false
(= true false)                 ; => false
(= 'yeah 'lol)                 ; => false
#+end_src

** ~(!= VALUE ...)~
Binary opposite of ~(=)~.

#+begin_src lisp
(= "string" "string" "string") ; => false
(= 5 5.0 (/ 25 5))             ; => false
(= 'yeah 'yeah)                ; => false
(= nil nil)                    ; => false

(= "foo" "bar")                ; => true
(= 5 7)                        ; => true
(= true false)                 ; => true
(= 'yeah 'lol)                 ; => true
#+end_src

* Types
** ~(nil? VALUE)~
Checks if ~VALUE~ is ~nil~ or ~()~.

#+begin_src lisp
(nil? nil)   ; => true
(nil? '())   ; => true
(nil? false) ; => false
#+end_src

** ~(number? VALUE)~
Checks if ~VALUE~ is a number.

#+begin_src lisp
(number? nil)   ; => false
(number? '(1))  ; => false
(number? false) ; => false
 number
(number? 1)     ; => true
#+end_src

** ~(string? VALUE)~
Checks if ~VALUE~ is a string.

#+begin_src lisp
(string? nil)   ; => false
(string? '(1))  ; => false
(string? false) ; => false

(string? "str") ; => true
#+end_src

** ~(bool? VALUE)~
Checks if ~VALUE~ is a boolean.

#+begin_src lisp
(bool? nil)   ; => false
(bool? '(1))  ; => false
(bool? false) ; => false

(bool? "str") ; => true
#+end_src

* Arithmetic conditions
** ~(< VALUE ...)~
Checks if the values are less than each other sequentially.

#+begin_src lisp
(< 1 2 3 4 5) ; => true
(< 2 2 3 4 5) ; => false
(< 1 2 6 4 5) ; => false
#+end_src

** ~(<= VALUE ...)~
Checks if the values are less than or equal to each other sequentially.

#+begin_src lisp
(<= 1 2 3 4 5) ; => true
(<= 2 2 3 4 5) ; => true
(< 1 2 6 4 5)  ; => false
#+end_src

** ~(> VALUE ...)~
Checks if the values are greater than each other sequentially.

#+begin_src lisp
(> 5 4 3 2 1) ; => true
(> 5 4 3 2 2) ; => false
(> 5 4 6 2 1) ; => false
#+end_src

** ~(>= VALUE ...)~
Checks if the values are greater than or equal to each other sequentially.

#+begin_src lisp
(>= 5 4 3 2 1) ; => true
(>= 5 4 3 2 2) ; => true
(>= 5 4 6 2 1) ; => false
#+end_src

* Arithmetic operations
** ~(+ VALUE ...)~
Adds the values sequentially.

#+begin_src lisp
(+ 1 2 3 4) ; => 10
(+)         ; => 0
#+end_src

** ~(- VALUE ...)~
Substracts the values sequentially. If only one value is provided, it
negates it.

#+begin_src lisp
(- 10 4 3 2) ; => 1
(- 4)        ; => -4
(-)          ; => 0
#+end_src

** ~(* VALUE ...)~
Multiplies the values sequentially.

#+begin_src lisp
(* 1 2 3 4) ; => 24
(*)         ; => 1
#+end_src

** ~(/ VALUE ...)~
Divides the values sequentially.

#+begin_src lisp
(/ 18 2 2 2) ; => 2.25
(/)          ; => 1
#+end_src

** ~(% VALUE ...)~
Performs modulo on the values sequentially.

#+begin_src lisp
(% 5 4 3 2) ; => 1
(%)         ; => 0
#+end_src

* QoL functions
** ~(length SEQUENCE)~
Returns the number of items in ~SEQUENCE~.

#+begin_src lisp
(length "Hello, world") ; => 12
(length '(0 1 2 3 4))   ; 5
#+end_src

** ~(concat VALUE ...)~
Concat several values together into a single string.

#+begin_src lisp
(concat "Hello, " 'world)    ; => "Hello, world"
(length 42 " is the answer") ; => "42 is the answer"
#+end_src

** ~(range BOUND [BOUND])~
Generate a range of numbers, whose lower boundary defaults to ~0~. The
upper boundary is inclusive.

#+begin_src lisp
(range 5)   ; => (0 1 2 3 4 5)
(range 2 6) ; => (2 3 4 5 6)
#+end_src

** ~(even NUMBER)~
Return ~true~ if ~NUMBER~ is even.

#+begin_src lisp
(even 4) ; => true
(even 5) ; => false
#+end_src

** ~(odd NUMBER)~
Return ~true~ if ~NUMBER~ is odd.

#+begin_src lisp
(odd 5) ; => true
(odd 4) ; => false
#+end_src

** ~(map FUNCTION LIST)~
Execute ~FUNCTION~ on every item in ~LIST~ and generate a new list
from the results.

#+begin_src lisp
(map (lambda (n) (* n 2)) '(1 2 3 4)) ; => (2 4 6 8)
(map even '(1 2 3 4))                 ; => (false true false true)
#+end_src

** ~(filter FUNCTION LIST)~
Execute ~FUNCTION~ on every item in ~LIST~ and generate a new list
from the items for which ~(FUNCTION item)~ returned a truthy value.

#+begin_src lisp
(filter even '(1 2 3 4)) ; => (2 4)
(filter odd '(1 2 3 4))  ; => (1 3)
#+end_src
